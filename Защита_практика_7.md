# Защита практической работы №7
## Паттерны проектирования: структурные и поведенческие паттерны

---

## Часть 1. Общие задания

### 1.1 Adapter (Адаптер) — Структурный паттерн

**Цель паттерна:** Позволяет объектам с несовместимыми интерфейсами работать вместе, преобразуя интерфейс одного класса в интерфейс, ожидаемый клиентом.

**Задание:** Создать систему для воспроизведения аудиофайлов разных форматов (MP3 и WAV). Адаптер позволяет воспроизводить WAV-файлы через интерфейс MP3-плеера.

**Структура решения:**

```
practice7/Adapter/
├── MediaPlayer.java      — интерфейс с методом play()
├── MP3Player.java        — реализация для MP3 файлов
├── WAVPlayer.java        — класс для воспроизведения WAV
├── WAVtoMP3Adapter.java  — адаптер WAV → MP3
└── App.java              — демонстрация
```

**Ключевые классы:**

```java
// Интерфейс медиаплеера
public interface MediaPlayer {
    void play(String filename);
}

// Адаптер — ключевой класс паттерна
public class WAVtoMP3Adapter implements MediaPlayer {
    private WAVPlayer wavPlayer = new WAVPlayer();

    @Override
    public void play(String filename) {
        if (filename.endsWith(".wav")) {
            wavPlayer.playWAV(filename);
        } else {
            System.out.println("Формат не поддерживается");
        }
    }
}
```

**Принцип работы:**
- `MediaPlayer` — единый интерфейс для воспроизведения
- `MP3Player` — напрямую реализует интерфейс
- `WAVtoMP3Adapter` — адаптирует `WAVPlayer` к интерфейсу `MediaPlayer`

**Вывод программы:**
```
Playing MP3: song5.mp3
Playing WAV: audio3.wav
Format not supported: audio3.wav
Format not supported: song5.mp3
```

---

### 1.2 Chain of Responsibility (Цепочка обязанностей) — Поведенческий паттерн

**Цель паттерна:** Позволяет передавать запрос последовательно по цепочке обработчиков. Каждый обработчик решает, обработать запрос или передать его следующему.

**Задание:** Реализовать систему логирования с обработчиками для уровней INFO, WARNING, ERROR, CRITICAL, DEBUG.

**Структура решения:**

```
practice7/ChainofResponsibility/
├── Logger.java         — абстрактный базовый класс
├── InfoLogger.java     — обработчик INFO
├── WarningLogger.java  — обработчик WARNING
├── ErrorLogger.java    — обработчик ERROR
├── CriticalLogger.java — обработчик CRITICAL
├── DebugLogger.java    — обработчик DEBUG
├── LoggerFactory.java  — фабрика для создания цепочки
└── App.java            — демонстрация
```

**Ключевые классы:**

```java
// Абстрактный логгер с поддержкой цепочки
public abstract class Logger {
    protected Logger nextLogger;

    public void setNextLogger(Logger nextLogger) {
        this.nextLogger = nextLogger;
    }

    public void log(String level, String message) {
        if (canHandle(level)) {
            write(message);
        }
        if (nextLogger != null) {
            nextLogger.log(level, message);
        }
    }

    protected abstract boolean canHandle(String level);
    protected abstract void write(String message);
}

// Пример конкретного обработчика
public class InfoLogger extends Logger {
    @Override
    protected boolean canHandle(String level) {
        return "INFO".equals(level);
    }

    @Override
    protected void write(String message) {
        System.out.println("[INFO] " + message);
    }
}
```

**Принцип работы:**
1. Создаётся цепочка логгеров: DEBUG → INFO → WARNING → ERROR → CRITICAL
2. Запрос передаётся по цепочке
3. Каждый логгер проверяет, может ли он обработать запрос
4. Если да — обрабатывает, затем передаёт дальше

**Вывод программы:**
```
[INFO] User authentication successful
[WARNING] Password expires in 5 days - consider updating it
[ERROR] Connection timeout to database
```

---

## Часть 2. Вариант №7

### 2.1 Proxy (Заместитель) — Структурный паттерн

**Цель паттерна:** Контролирует доступ к объекту, предоставляя его замену или дополнительный уровень управления. Используется для отложенной инициализации (lazy loading).

**Задание:** Создать систему загрузки изображений с прокси. Изображение загружается только при первом вызове `display()`.

**Структура решения:**

```
practice7/Proxy/
├── Image.java       — интерфейс с методом display()
├── RealImage.java   — реальное изображение (тяжёлая загрузка)
├── ProxyImage.java  — прокси (отложенная загрузка)
└── App.java         — демонстрация
```

**Реализация:**

```java
// Интерфейс изображения
public interface Image {
    void display();
}

// Реальное изображение — загружается при создании
public class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();  // Тяжёлая операция
    }

    private void loadFromDisk() {
        System.out.println("Загрузка изображения: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Отображение изображения: " + filename);
    }
}

// Прокси — откладывает загрузку до первого использования
public class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
        // Загрузка НЕ происходит при создании!
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);  // Ленивая загрузка
        }
        realImage.display();
    }
}
```

**Демонстрация:**

```java
public class App {
    public static void main(String[] args) {
        Image image1 = new ProxyImage("photo1.jpg");
        Image image2 = new ProxyImage("photo2.jpg");

        System.out.println("Изображения созданы, но еще не загружены\n");

        System.out.println("Первый вызов display() для image1:");
        image1.display();  // Здесь происходит загрузка

        System.out.println("\nВторой вызов display() для image1:");
        image1.display();  // Повторная загрузка НЕ происходит

        System.out.println("\nПервый вызов display() для image2:");
        image2.display();  // Здесь происходит загрузка image2
    }
}
```

**Вывод программы:**
```
Изображения созданы, но еще не загружены

Первый вызов display() для image1:
Загрузка изображения: photo1.jpg
Отображение изображения: photo1.jpg

Второй вызов display() для image1:
Отображение изображения: photo1.jpg

Первый вызов display() для image2:
Загрузка изображения: photo2.jpg
Отображение изображения: photo2.jpg
```

**Преимущества паттерна Proxy:**
- Экономия ресурсов — объект создаётся только когда нужен
- Контроль доступа — можно добавить проверки перед доступом
- Прозрачность — клиент работает с прокси как с реальным объектом

---

### 2.2 State (Состояние) — Поведенческий паттерн

**Цель паттерна:** Позволяет объекту изменять своё поведение при изменении внутреннего состояния. Объект как будто меняет свой класс.

**Задание:** Создать систему управления состоянием заказа в интернет-магазине (New → Processing → Shipped).

**Структура решения:**

```
practice7/State/
├── State.java           — интерфейс с методом handle()
├── NewState.java        — состояние "Новый заказ"
├── ProcessingState.java — состояние "В обработке"
├── ShippedState.java    — состояние "Отправлен"
├── Order.java           — контекст (заказ)
└── App.java             — демонстрация
```

**Реализация:**

```java
// Интерфейс состояния
public interface State {
    void handle(Order order);
}

// Состояние "Новый заказ"
public class NewState implements State {
    @Override
    public void handle(Order order) {
        System.out.println("Заказ создан. Переход в обработку...");
        order.setState(new ProcessingState());
    }
}

// Состояние "В обработке"
public class ProcessingState implements State {
    @Override
    public void handle(Order order) {
        System.out.println("Заказ обрабатывается. Отправка...");
        order.setState(new ShippedState());
    }
}

// Состояние "Отправлен" (конечное)
public class ShippedState implements State {
    @Override
    public void handle(Order order) {
        System.out.println("Заказ уже отправлен. Ожидайте доставку.");
    }
}

// Контекст — заказ
public class Order {
    private State state;

    public Order() {
        this.state = new NewState();  // Начальное состояние
    }

    public void setState(State state) {
        this.state = state;
    }

    public State getState() {
        return state;
    }

    public void nextState() {
        state.handle(this);
    }
}
```

**Демонстрация:**

```java
public class App {
    public static void main(String[] args) {
        Order order = new Order();

        System.out.println("Текущее состояние: " +
            order.getState().getClass().getSimpleName());
        order.nextState();  // New → Processing

        System.out.println("\nТекущее состояние: " +
            order.getState().getClass().getSimpleName());
        order.nextState();  // Processing → Shipped

        System.out.println("\nТекущее состояние: " +
            order.getState().getClass().getSimpleName());
        order.nextState();  // Shipped (конечное)

        System.out.println("\nПопытка перехода из конечного состояния:");
        order.nextState();  // Остаётся в Shipped
    }
}
```

**Вывод программы:**
```
Текущее состояние: NewState
Заказ создан. Переход в обработку...

Текущее состояние: ProcessingState
Заказ обрабатывается. Отправка...

Текущее состояние: ShippedState
Заказ уже отправлен. Ожидайте доставку.

Попытка перехода из конечного состояния:
Заказ уже отправлен. Ожидайте доставку.
```

**Диаграмма переходов:**
```
[New] → [Processing] → [Shipped]
                          ↺
```

**Преимущества паттерна State:**
- Устраняет множественные условные операторы (if/switch)
- Легко добавлять новые состояния
- Каждое состояние инкапсулирует своё поведение
- Переходы между состояниями явные и понятные

---

## Контрольные вопросы

### По паттерну Adapter:
1. **В чём разница между Object Adapter и Class Adapter?**
   - Object Adapter использует композицию (хранит ссылку на адаптируемый объект)
   - Class Adapter использует множественное наследование (в Java — через интерфейсы)

2. **Когда использовать Adapter?**
   - При интеграции несовместимых интерфейсов
   - При работе со сторонними библиотеками
   - При миграции старого кода

### По паттерну Chain of Responsibility:
1. **Как определяется порядок обработчиков?**
   - Порядок определяется при создании цепочки (в LoggerFactory)
   - Каждый обработчик знает только о следующем

2. **Что если ни один обработчик не обработает запрос?**
   - Запрос может остаться необработанным
   - Можно добавить обработчик по умолчанию в конец цепочки

### По паттерну Proxy:
1. **Какие виды Proxy существуют?**
   - Virtual Proxy — отложенная инициализация (наш случай)
   - Protection Proxy — контроль доступа
   - Remote Proxy — работа с удалёнными объектами
   - Cache Proxy — кеширование результатов

2. **Чем Proxy отличается от Decorator?**
   - Proxy контролирует доступ к объекту
   - Decorator добавляет новую функциональность

### По паттерну State:
1. **Кто определяет переходы между состояниями?**
   - Сами состояния (как в нашем примере)
   - Или контекст (Order) может управлять переходами

2. **Чем State отличается от Strategy?**
   - State — объект меняет поведение при смене состояния
   - Strategy — клиент выбирает алгоритм извне

---

## Выводы

В практической работе №7 были изучены и реализованы:

1. **Структурные паттерны:**
   - Adapter — для совместимости интерфейсов
   - Proxy — для контроля доступа и отложенной загрузки

2. **Поведенческие паттерны:**
   - Chain of Responsibility — для последовательной обработки запросов
   - State — для управления состоянием объекта

Все паттерны демонстрируют принципы SOLID, особенно:
- **Single Responsibility** — каждый класс отвечает за одну задачу
- **Open/Closed** — легко расширять без изменения существующего кода
- **Dependency Inversion** — зависимость от абстракций, а не от конкретных реализаций
